# 热度排行榜实现文档

## 1. 概述

热度排行榜功能使用 Redis Sorted Set 实现综合热度排序，通过加权计算多个维度（点赞、收藏、评论、分享）得到综合热度分数。支持多个时间段（日榜、周榜、月榜、总榜）的排行榜。

## 2. 业界常见的热度算法

### 2.1 简单加权法（本项目采用）
**原理**：热度 = 点赞数 × 权重1 + 收藏数 × 权重2 + 评论数 × 权重3 + 分享数 × 权重4

**特点**：
- ✅ 实现简单
- ✅ 可配置权重
- ✅ 计算速度快
- ⚠️ 权重需要人工调优

**应用场景**：
- 中小型内容平台
- 需要快速上线的场景

### 2.2 时间衰减法
**原理**：热度 = 基础分数 × 时间衰减因子，新内容有加成。

**特点**：
- ✅ 新内容有机会上热门
- ✅ 避免老内容长期霸榜
- ⚠️ 实现复杂度较高

**应用场景**：
- 需要平衡新老内容的场景
- 内容更新频繁的场景

### 2.3 机器学习算法
**原理**：使用机器学习模型预测内容热度。

**特点**：
- ✅ 准确度高
- ✅ 自适应调整
- ❌ 实现复杂度极高
- ❌ 需要大量数据训练

**应用场景**：
- 大型内容平台
- 有机器学习团队的场景

### 2.4 Reddit/Hacker News 算法
**原理**：热度 = (点赞数 - 点踩数) / (时间 + 2)^1.5

**特点**：
- ✅ 考虑时间因素
- ✅ 避免刷榜
- ⚠️ 需要点踩功能

**应用场景**：
- 有正负反馈的场景
- 需要时间衰减的场景

## 3. 本项目的实现方式

### 3.1 热度算法

#### 计算公式
```
热度分数 = 点赞数 × 0.4 + 收藏数 × 0.3 + 评论数 × 0.2 + 分享数 × 0.1
```

**权重配置**：
- 点赞权重：0.4（最高）
- 收藏权重：0.3
- 评论权重：0.2
- 分享权重：0.1（暂未实现）

**设计思路**：
- 点赞最能反映内容质量，权重最高
- 收藏表示用户认可，权重较高
- 评论表示用户参与度，权重中等
- 分享表示传播度，权重较低（暂未实现）

### 3.2 数据存储结构

#### Redis Sorted Set
- **日榜**：`post:ranking:hot:daily`
- **周榜**：`post:ranking:hot:weekly`
- **月榜**：`post:ranking:hot:monthly`
- **总榜**：`post:ranking:hot:alltime`
- **Score**：综合热度分数
- **Member**：帖子ID（postId）

**示例**：
```
Key: post:ranking:hot:daily
Sorted Set:
  - postId: 456, score: 850.5 (热度分数)
  - postId: 789, score: 720.3
  - postId: 123, score: 650.1
```

### 3.3 Redis 命令使用

| 命令 | 用途 | 示例 |
|------|------|------|
| `ZADD` | 更新热度分数 | `ZADD post:ranking:hot:daily 850.5 456` |
| `ZREVRANGE` | 获取排行榜（按分数从高到低） | `ZREVRANGE post:ranking:hot:daily 0 19` |
| `ZREVRANK` | 获取排名（0-based） | `ZREVRANK post:ranking:hot:daily 456` |
| `ZSCORE` | 获取热度分数 | `ZSCORE post:ranking:hot:daily 456` |

### 3.4 核心功能实现

#### 3.4.1 更新热度分数
**功能**：当用户点赞、收藏、评论时，重新计算并更新热度分数

**实现方式**：
- `updateHotScore(postId)`：重新计算热度分数并更新所有时间段的排行榜
- `onLike(postId)`：点赞时调用
- `onUnlike(postId)`：取消点赞时调用
- `onFavorite(postId)`：收藏时调用
- `onUnfavorite(postId)`：取消收藏时调用
- `onComment(postId)`：评论时调用

**计算流程**：
1. 从 `RankingService` 获取实时统计数据（点赞数、收藏数、评论数）
2. 使用公式计算综合热度分数
3. 更新所有时间段的排行榜（日榜、周榜、月榜、总榜）

**特点**：
- 实时更新，立即生效
- 所有时间段同步更新
- 从 Redis 获取统计数据，避免数据库查询

#### 3.4.2 获取热度排行榜
**功能**：获取指定时间段的排行榜

**实现方式**：
- `getHotPosts(period, page, pageSize)`：获取排行榜
- `period` 参数：`daily`（日榜）、`weekly`（周榜）、`monthly`（月榜）、`alltime`（总榜）

**查询逻辑**：
- 使用 `ZREVRANGE` 按分数从高到低获取
- 支持分页查询

#### 3.4.3 获取排名和分数
**功能**：获取某个帖子在排行榜中的排名和热度分数

**实现方式**：
- `getPostRank(postId, period)`：获取排名（1-based）
- `getHotScore(postId, period)`：获取热度分数

## 4. 使用场景

### 4.1 首页热门推荐
**场景**：在首页展示热门帖子

**实现**：
```
List<Long> hotPosts = hotRankingService.getHotPosts("daily", 1, 20);
```

### 4.2 多时间段排行榜
**场景**：提供日榜、周榜、月榜、总榜切换

**实现**：
```
// 日榜
List<Long> dailyHot = hotRankingService.getHotPosts("daily", 1, 20);

// 周榜
List<Long> weeklyHot = hotRankingService.getHotPosts("weekly", 1, 20);

// 月榜
List<Long> monthlyHot = hotRankingService.getHotPosts("monthly", 1, 20);

// 总榜
List<Long> alltimeHot = hotRankingService.getHotPosts("alltime", 1, 20);
```

### 4.3 排名展示
**场景**：在帖子详情页展示排名

**实现**：
```
Long rank = hotRankingService.getPostRank(postId, "daily");
Double score = hotRankingService.getHotScore(postId, "daily");
```

## 5. 性能优化

### 5.1 实时计算
- 从 Redis 获取统计数据，避免数据库查询
- 计算速度快，内存操作

### 5.2 批量更新
- 所有时间段同步更新，保证数据一致性
- 使用 `ZADD` 原子性操作

### 5.3 定时清理
- 定时清理过期数据（超过一定时间未更新的数据）
- 避免排行榜过大

## 6. 优缺点分析

### 6.1 优点
1. **综合排序**：考虑多个维度，排序更合理
2. **可配置权重**：可以根据业务需求调整权重
3. **多时间段支持**：支持日榜、周榜、月榜、总榜
4. **实时更新**：统计数据实时更新，热度分数实时计算
5. **查询性能高**：Redis Sorted Set 查询性能 O(log N)

### 6.2 缺点
1. **权重需要调优**：权重需要根据业务数据调优
2. **未考虑时间因素**：新内容可能难以超越老内容（可以扩展时间衰减）
3. **内存占用**：所有时间段的数据都存储在 Redis 中
4. **计算开销**：每次更新需要重新计算热度分数

## 7. 适用场景

### 7.1 适用场景
- ✅ 需要综合排序的场景
- ✅ 需要多时间段排行榜的场景
- ✅ 数据量中等的场景（百万级以内）
- ✅ 需要实时更新的场景

### 7.2 不适用场景
- ❌ 只需要单维度排序的场景：可以使用 `RankingService`
- ❌ 数据量极大的场景（亿级）：建议使用定时计算法
- ❌ 需要时间衰减的场景：需要扩展算法

## 8. 扩展功能

### 8.1 时间衰减
- 新内容有加成（如24小时内发布的内容热度 × 1.2）
- 老内容随时间衰减

### 8.2 动态权重
- 根据内容类型调整权重（如视频内容分享权重更高）
- 根据用户行为调整权重

### 8.3 热度趋势
- 统计热度变化趋势
- 预测内容热度

### 8.4 防刷机制
- 检测异常点赞、收藏行为
- 过滤刷榜内容


