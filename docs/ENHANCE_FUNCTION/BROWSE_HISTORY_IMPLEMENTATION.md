# 浏览历史实现文档

## 1. 概述

浏览历史功能使用 Redis Sorted Set 和数据库实现，记录用户浏览帖子的历史记录，支持按时间倒序查询、分页查询、时间范围查询等功能。采用热冷数据分离策略，Redis 存储最近3天的热数据，数据库存储历史冷数据。

## 2. 业界常见的浏览历史实现方法

### 2.1 数据库存储法
**原理**：将所有浏览记录存储在数据库中，通过索引优化查询性能。

**特点**：
- ✅ 数据持久化，不会丢失
- ✅ 支持复杂查询和统计分析
- ❌ 查询性能受数据量影响
- ❌ 数据库压力大

**应用场景**：
- 需要长期保存浏览历史的场景
- 需要复杂统计分析的场景

### 2.2 Redis 存储法
**原理**：使用 Redis 存储浏览历史，利用 Redis 的高性能特性。

**特点**：
- ✅ 查询速度快
- ✅ 支持按时间排序
- ❌ 数据可能丢失（Redis 重启）
- ❌ 存储空间有限

**应用场景**：
- 只需要最近浏览历史的场景
- 对查询性能要求高的场景

### 2.3 热冷数据分离法（本项目采用）
**原理**：Redis 存储热数据（最近N天），数据库存储冷数据（历史数据）。

**特点**：
- ✅ 兼顾性能和持久化
- ✅ 查询速度快（热数据）
- ✅ 数据不丢失（冷数据）
- ⚠️ 实现复杂度较高

**应用场景**：
- 需要长期保存且对性能有要求的场景
- 大型内容平台

## 3. 本项目的实现方式

### 3.1 数据存储策略

#### Redis存储（热数据）
- **存储内容**：最近3天的浏览记录
- **数据结构**：Redis Sorted Set
- **Key格式**：`browse:history:user:{userId}`
- **Score**：浏览时间戳（毫秒）
- **Member**：帖子ID（postId）
- **限制**：默认最多保留1000条记录（通过 Lua 脚本自动清理）

**示例**：
```
Key: browse:history:user:123
Sorted Set:
  - postId: 456, score: 1703123456789
  - postId: 789, score: 1703123456790
  - postId: 101, score: 1703123456791
```

#### 数据库存储（冷数据）
- **存储内容**：3天前的浏览记录
- **表结构**：`browse_history` 表
- **字段**：
  - `user_id`: 用户ID
  - `post_id`: 帖子ID
  - `browse_time`: 浏览时间（时间戳）

**数据迁移**：
- 定时任务每天执行
- 将超过3天的Redis数据持久化到数据库
- 从Redis删除已持久化的数据

### 3.2 Redis Sorted Set的使用

#### 为什么使用Sorted Set？
1. **自动排序**：按时间戳（score）自动排序，最新浏览在前
2. **去重更新**：同一帖子多次浏览，自动更新为最新时间
3. **高效查询**：支持按时间范围查询、分页查询
4. **灵活操作**：支持 `ZADD`、`ZREVRANGE`、`ZRANGEBYSCORE` 等操作

#### 使用的Redis命令

| 命令 | 用途 | 示例 |
|------|------|------|
| `ZADD` | 添加浏览记录（自动去重，更新时间为最新） | `ZADD browse:history:user:123 1703123456789 456` |
| `ZREVRANGE` | 获取浏览历史（按时间倒序） | `ZREVRANGE browse:history:user:123 0 19` |
| `ZRANGEBYSCORE` | 按时间范围查询 | `ZRANGEBYSCORE browse:history:user:123 startTime endTime` |
| `ZSCORE` | 获取浏览时间 | `ZSCORE browse:history:user:123 456` |
| `ZREM` | 删除浏览记录 | `ZREM browse:history:user:123 456` |
| `ZCARD` | 获取浏览记录数量 | `ZCARD browse:history:user:123` |
| `ZREMRANGEBYSCORE` | 按时间范围删除 | `ZREMRANGEBYSCORE browse:history:user:123 0 expireTime` |
| `ZREMRANGEBYRANK` | 按排名删除（限制数量） | `ZREMRANGEBYRANK browse:history:user:123 0 -1001` |

### 3.3 核心功能实现

#### 3.3.1 记录浏览
**功能**：用户浏览帖子时，记录浏览历史

**实现**：
- 使用 Lua 脚本原子性地执行：`ZADD` + `ZCARD` + `ZREMRANGEBYRANK`
- 如果记录数超过1000条，自动删除最旧的记录
- 同一帖子多次浏览，自动更新为最新时间

**特点**：
- 原子性操作，避免并发问题
- 自动限制数量，防止内存无限增长
- 自动去重，同一帖子只保留最新浏览时间

#### 3.3.2 获取浏览历史
**功能**：获取用户的浏览历史列表

**实现方式**：
- 支持按数量查询（`getBrowseHistory(userId, limit)`）
- 支持分页查询（`getBrowseHistory(userId, page, pageSize)`）
- 支持时间范围查询（`getBrowseHistoryByTimeRange(userId, startTime, endTime)`）

**查询策略**：
1. 先从Redis查询最近3天的数据
2. 如果数据不足，从数据库补充
3. 合并Redis和数据库的结果，去重并按时间倒序

#### 3.3.3 检查是否已浏览
**功能**：检查用户是否浏览过某个帖子

**实现**：
- 先检查Redis（使用 `ZSCORE`）
- 如果未找到，再查询数据库

#### 3.3.4 获取浏览时间
**功能**：获取用户浏览某个帖子的时间

**实现**：
- 先检查Redis（使用 `ZSCORE`）
- 如果未找到，从数据库查询

#### 3.3.5 清理浏览历史
**功能**：清理用户的浏览历史

**实现**：
- `clearBrowseHistory(userId)`：清空所有浏览历史
- `clearOldBrowseHistory(userId, expireTime)`：清理过期记录

## 4. 性能优化

### 4.1 热冷数据分离
- **热数据（Redis）**：最近3天的数据，查询速度快
- **冷数据（数据库）**：历史数据，查询相对较慢但存储成本低

### 4.2 自动限制数量
- 使用 Lua 脚本在添加记录时自动限制数量（最多1000条）
- 避免内存无限增长
- 保证查询性能

### 4.3 批量操作
- 使用 `ZREMRANGEBYRANK` 批量删除旧记录
- 使用 `ZREVRANGE` 批量获取记录

### 4.4 去重优化
- Sorted Set 天然支持去重，同一帖子多次浏览只保留最新时间
- 合并Redis和数据库结果时，使用 `distinct()` 去重

## 5. 优缺点分析

### 5.1 优点
1. **查询性能高**：Redis Sorted Set 查询速度快，支持按时间排序
2. **自动去重**：同一帖子多次浏览，自动更新为最新时间
3. **自动限制**：通过 Lua 脚本自动限制记录数量，防止内存无限增长
4. **数据持久化**：冷数据存储在数据库，不会丢失
5. **灵活查询**：支持按数量、分页、时间范围等多种查询方式

### 5.2 缺点
1. **实现复杂度高**：需要处理Redis和数据库的数据合并
2. **数据一致性**：Redis和数据库可能存在短暂不一致（定时任务未执行）
3. **存储空间**：Redis存储空间有限，需要定期清理
4. **查询逻辑复杂**：需要判断数据在Redis还是数据库，然后合并结果

## 6. 适用场景

### 6.1 适用场景
- ✅ 需要记录用户浏览历史的场景
- ✅ 需要按时间倒序展示浏览历史的场景
- ✅ 需要支持分页查询的场景
- ✅ 需要长期保存浏览历史的场景

### 6.2 不适用场景
- ❌ 只需要最近浏览历史的场景（可以只用Redis）
- ❌ 不需要持久化的场景（可以只用Redis）
- ❌ 数据量很小的场景（可以只用数据库）

## 7. 扩展功能

### 7.1 浏览统计
- 统计用户浏览的帖子数量
- 统计用户浏览的帖子类型分布
- 统计用户浏览时间分布

### 7.2 推荐算法
- 基于浏览历史推荐相似内容
- 基于浏览历史推荐相关用户

### 7.3 浏览分析
- 分析用户浏览偏好
- 分析热门浏览内容
- 分析浏览时间趋势


