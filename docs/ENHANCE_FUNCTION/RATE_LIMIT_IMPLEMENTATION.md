# 限流服务实现文档

## 1. 概述

限流服务使用 Redis 和 Lua 脚本实现，支持滑动窗口和令牌桶两种限流算法。所有限流操作使用 Lua 脚本确保原子性，适用于 API 限流、接口保护、防止恶意请求等场景。

## 2. 业界常见的限流算法

### 2.1 固定窗口算法（Fixed Window）
**原理**：将时间划分为固定窗口，每个窗口内限制请求数量。

**特点**：
- ✅ 实现简单
- ❌ 临界点突刺问题（窗口切换时可能允许2倍请求）
- ❌ 不够平滑

**应用场景**：
- 对精度要求不高的场景

### 2.2 滑动窗口算法（本项目采用）
**原理**：使用滑动时间窗口，统计窗口内的请求数量。

**特点**：
- ✅ 精度高，避免临界点突刺
- ✅ 平滑限流
- ⚠️ 实现复杂度较高
- ⚠️ 需要存储窗口内的请求记录

**应用场景**：
- 需要精确限流的场景
- 对平滑性要求高的场景

### 2.3 令牌桶算法（本项目采用）
**原理**：维护一个令牌桶，以固定速率生成令牌，请求消耗令牌。

**特点**：
- ✅ 允许突发流量（桶容量）
- ✅ 平滑限流
- ✅ 实现相对简单
- ⚠️ 初始可能有瞬时并发

**应用场景**：
- 允许突发流量的场景
- 需要平滑限流的场景

### 2.4 漏桶算法（Leaky Bucket）
**原理**：维护一个漏桶，以固定速率处理请求，超出容量的请求被丢弃。

**特点**：
- ✅ 输出速率恒定
- ✅ 平滑限流
- ❌ 不允许突发流量

**应用场景**：
- 需要恒定输出速率的场景

## 3. 本项目的实现方式

### 3.1 滑动窗口实现

#### 数据存储结构
- **Key格式**：`limit:{key}`
- **数据结构**：Redis Sorted Set
- **Score**：请求时间戳（毫秒）
- **Member**：唯一请求ID

**实现原理**：
1. 使用 Sorted Set 存储窗口内的请求记录
2. 每次请求时，清理过期记录（窗口外的记录）
3. 统计窗口内的请求数量
4. 如果未超过限制，添加当前请求记录

**Lua 脚本流程**：
1. 清理过期记录（`ZREMRANGEBYSCORE`）
2. 统计窗口内请求数（`ZCARD`）
3. 如果未超过限制，添加当前请求（`ZADD`）
4. 返回剩余可用次数

### 3.2 令牌桶实现

#### 数据存储结构
- **Key格式**：`limit:{key}`
- **数据结构**：Redis Hash
- **Fields**：
  - `tokens`：当前令牌数
  - `lastRefill`：上次补充令牌的时间戳

**实现原理**：
1. 计算自上次补充以来的时间差
2. 根据速率补充令牌（不超过桶容量）
3. 如果令牌足够，消耗令牌并允许请求
4. 如果令牌不足，拒绝请求

**Lua 脚本流程**：
1. 获取当前令牌数和上次补充时间
2. 计算需要补充的令牌数
3. 更新令牌数（不超过桶容量）
4. 如果令牌足够，消耗令牌并返回允许
5. 如果令牌不足，返回拒绝

### 3.3 Redis 命令使用

| 命令 | 用途 | 示例 |
|------|------|------|
| `ZADD` | 添加请求记录（滑动窗口） | `ZADD limit:key timestamp requestId` |
| `ZREMRANGEBYSCORE` | 清理过期记录（滑动窗口） | `ZREMRANGEBYSCORE limit:key 0 expireTime` |
| `ZCARD` | 统计窗口内请求数（滑动窗口） | `ZCARD limit:key` |
| `HGET` | 获取令牌数（令牌桶） | `HGET limit:key tokens` |
| `HSET` | 更新令牌数（令牌桶） | `HSET limit:key tokens 10` |

### 3.4 核心功能实现

#### 3.4.1 限流检查
**功能**：检查请求是否允许通过

**实现方式**：
- `allowRequest(key, limit, windowSize, unit)`：检查是否允许请求
- `tryAcquire(key, limit, windowSize, unit)`：尝试获取许可，返回剩余次数

**参数说明**：
- `key`：限流key（可以是用户ID、IP地址等）
- `limit`：限制数量
- `windowSize`：时间窗口大小
- `unit`：时间单位

#### 3.4.2 注解方式限流
**功能**：通过注解方式实现限流

**实现方式**：
- 使用 `@RateLimit` 注解标记需要限流的方法
- 支持 SpEL 表达式动态生成限流key
- 支持选择限流算法（滑动窗口或令牌桶）

**示例**：
```
@RateLimit(key = "user:#{#userId}", limit = 100, window = 1, unit = TimeUnit.MINUTES)
public void someMethod(Long userId) {
    // ...
}
```

#### 3.4.3 限流处理
**功能**：处理被限流的请求

**实现方式**：
- 被限流时返回默认值或抛出异常
- 支持自定义限流消息

## 4. 使用场景

### 4.1 API 限流
**场景**：限制 API 调用频率

**实现**：
```
// 每个用户每分钟最多100次请求
rateLimitService.getWithLimit("api:user:" + userId, 100, 1, TimeUnit.MINUTES);
```

### 4.2 接口保护
**场景**：防止接口被恶意请求

**实现**：
```
@RateLimit(key = "ip:#{#request.getRemoteAddr()}", limit = 10, window = 1, unit = TimeUnit.SECONDS)
public void sensitiveOperation() {
    // ...
}
```

### 4.3 资源保护
**场景**：保护数据库、缓存等资源

**实现**：
```
// 限制数据库查询频率
rateLimitService.getWithLimit("db:query", 1000, 1, TimeUnit.SECONDS);
```

## 5. 性能优化

### 5.1 Lua 脚本原子性
- 所有限流操作使用 Lua 脚本，确保原子性
- 避免并发问题

### 5.2 自动清理过期数据
- 滑动窗口自动清理过期记录
- 避免内存无限增长

### 5.3 唯一请求ID
- 使用唯一请求ID作为 Sorted Set 的 member
- 避免重复计数

## 6. 优缺点分析

### 6.1 优点
1. **精度高**：滑动窗口算法精度高，避免临界点突刺
2. **平滑限流**：令牌桶算法支持平滑限流和突发流量
3. **原子性操作**：使用 Lua 脚本保证并发安全
4. **灵活配置**：支持多种限流策略和参数配置
5. **注解支持**：支持注解方式，使用方便

### 6.2 缺点
1. **内存占用**：滑动窗口需要存储窗口内的请求记录
2. **Redis 依赖**：依赖 Redis，Redis 故障会影响限流
3. **分布式一致性**：多实例部署时，需要共享 Redis

## 7. 适用场景

### 7.1 适用场景
- ✅ 需要精确限流的场景
- ✅ 需要平滑限流的场景
- ✅ 已有 Redis 基础设施的场景
- ✅ 需要防止恶意请求的场景

### 7.2 不适用场景
- ❌ 对限流精度要求不高的场景：可以使用固定窗口算法
- ❌ 没有 Redis 基础设施的场景：可以使用内存限流

## 8. 扩展功能

### 8.1 多级限流
- 支持多级限流（如用户级、IP级、全局级）
- 支持限流策略组合

### 8.2 限流统计
- 统计限流情况
- 分析限流效果

### 8.3 动态调整
- 根据系统负载动态调整限流参数
- 支持限流规则热更新


